"
I can handle messages with a two byte size after the
    type and then followed by the usual TV
"
Class {
	#name : #IPAMsgResponse,
	#superclass : #IPAMsgRequest,
	#category : #'OsmoNetwork-IPA'
}

{ #category : #parsing }
IPAMsgResponse class >> parse: aStream [
	| type data |
	type := aStream next.
	"TLV parser for the IPAMessage"
	aStream skip: 1.
	data := self parseTLV: aStream.
	^(self new)
	    type: type;
	    data: data;
	    yourself

]

{ #category : #'as yet unclassified' }
IPAMsgResponse class >> parseTLV: aStream [
	"The messages generated by the ip.access nanoBTS do not follow
	 the TLV pattern properly. For responses the length does not include
	 the size of the tag and to make it worse sometimes the wrong size
	 is sent, e.g. there strings are null-terminated."

	| data |
	data := OrderedCollection new.
	[aStream atEnd] whileFalse: 
		[| tag len string |
		len := aStream next.
		tag := aStream next.
		string := self readByteString: aStream length: len.
		data add: (Association key: tag value: string)].
	^data

]

{ #category : #'as yet unclassified' }
IPAMsgResponse class >> readByteString: aStream length: aLen [
	"Read a IPA string from a stream that might be up to len."

	| str |
	str := WriteStream on: (ByteArray new: aLen).
	(1 to: aLen) do: 
		[:each | 
		| chr |
		chr := aStream next.
		str nextPut: chr.

		"deal with broken messages. so far only observed at the end
		 of a packet"
		(aStream atEnd and: [chr = 16r0]) ifTrue: [^str contents]].
	^str contents

]

{ #category : #serialize }
IPAMsgResponse >> writeOn: aMsg [
	aMsg putByte: type.
	aMsg putByte: 0.
	self writeTLV: aMsg

]

{ #category : #serialize }
IPAMsgResponse >> writeTLV: aMsg [
	"Request/Response appear to have different size constraints"
	data do: 
		[:each | 
		"Write the length and tag"

		aMsg
		    putByte: each value basicSize;
		    putByte: each key;
		    putByteArray: each value]

]
